---
title: "AirBNB Zillow Data Challenge for Capital One"
author: "Aadish Chopra"
date: "7/8/2019"
output: html_document
code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,fig.width = 10,warning = FALSE,message = FALSE)
options(scipen=99999)

```

Sourcing the boostrap file and change the global paramters


```{r loadbootstrap}
# data is assumed to be locally available 

# otherwise we can clone the repository and then do a pull 
# Load all the libraries 

required_packages<-c('knitr','dplyr','htmlTable','stringr','ggplot2','prophet','gridExtra','scales','mice')
load_required_packages<-function(required_packages){
  if(!require(required_packages,character.only = TRUE))
  {
    install.packages(required_packages)
    require(required_packages,character.only = TRUE)
  }
  else
  {
    require(required_packages,character.only = TRUE)
  }
}

lapply(required_packages,load_required_packages )

# Import the dataset
if(!file.exists('data/listings.csv'))
{
  listing_tar<-download.file(url="http://data.insideairbnb.com/united-states/ny/new-york-city/2017-05-02/data/listings.csv.gz",destfile = "data/listings.csv.gz")
  untar(tarfile = 'data/listings.csv.gz',exdir = 'data')  
}

if(!file.exists('data/Zip_Zhvi_2bedroom.csv')){
untar(tarfile = 'data/Zip_Zhvi_2bedroom.csv.zip',exdir = 'data')
}

AirBNB<-read.csv(file = "data/listings.csv",header = T,sep = ",",stringsAsFactors = F)
ZillowData<-read.csv("data/Zip_Zhvi_2bedroom.csv",header = T,sep = ",",stringsAsFactors = F)


```




```{r load_helper_functions}
removethesecolumns<-function(pattern_remove,dataset)
{
  #stricter type checking can also be used but leaving that out here 
  message(" removing column ")
  message(grep(pattern = pattern_remove,x = names(dataset),value = T))
  dataset %>% select(-contains(pattern_remove,ignore.case = TRUE))
}

analyze_distinct_values<-function(column)
{
  length(unique(column))
}

strip_money<-function(dataset,pattern){
  colnames(dataset[grep(pattern,colnames(dataset))])
}

remove_sign<-function(money,column)
{
  gsub(money,replacement = '',x =column )
}

noofNA<-function(column)
  {
  
  if(sum(is.na(column))>0)
  {
    sum(is.na(column))
  }
}


Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}


```




# Exploratory data analysis


```{r dimension analysis}
dim(AirBNB)
dim(ZillowData)

```

We see that AirBNB has 95 dimensions with 40753 observations and Zillow has 262 dimensions with 8946 observations.


# Analyzing Zillow data set

Filtering for new york City
```{r analyze_zillow,warning=FALSE,message=FALSE}

Z_NY<-ZillowData %>% filter(City=="New York") %>%
select(-c(RegionID,City,State,Metro,CountyName,SizeRank))
colnames(Z_NY)[1]<-"zipcode"
trans_zil = setNames(data.frame(t(Z_NY[,-1])), Z_NY[,1])
present<-data.frame(ds=seq.Date(from = as.Date('1996/04/01'),to = as.Date('2017/06/01'),by = 'month'))
future<-data.frame(ds=seq.Date(from = as.Date('1996/04/01'),to = as.Date('2019/08/01'),by = 'month'))
bind_for_prophet<-apply(trans_zil,2,cbind.data.frame,present)
bind_for_prophet<-lapply(bind_for_prophet, setNames,c('y','ds'))
make_model<-lapply(bind_for_prophet, prophet)
forecast<-lapply(make_model, predict,future)
extract_yhat<-lapply(forecast, function(x) x[, 'yhat'][nrow(future)])
Z_NY$predicted_price<-unlist(extract_yhat)


# create examples to show fitting and plotting 
dyplot.prophet(make_model$`10025`,forecast$`10025`)


cols<-c('zipcode','X2017.06','predicted_price')

# Use this

Z_NY_predicted<-Z_NY[,cols]
Z_NY_predicted$zipcode<-as.factor(Z_NY_predicted$zipcode)


#mapply(dyplot.prophet , make_model,forecast)



```





##Exploring AIRBNB data

Let's us look at the data first. The metadata is also available in the docx document

```{r viewdata ,eval=FALSE,echo=FALSE}

# Looking at the first 90 columns 
out_table <- cbind(names(AirBNB)[1:30],names(AirBNB)[31:60],names(AirBNB)[61:90])
htmlTable(out_table,
          cgroup = c("Set 1:30", "Set 31:60","Set 61:90"),
          n.cgroup = c(3),
          rnames = FALSE)


```



Price and other columns associated with money are listed in dollars. For example $50. In order to do analysis we will be stripping the dollar sign off of the entire column 


```{r columntypes,warning=FALSE,message=FALSE}

#stripping the dollar sign off


#identify which columns needs stripping
remove_dollar<-strip_money(pattern = 'price',dataset = AirBNB)

#manually inspecting
#colnames(AirBNB[AirBNB %>% str_detect(pattern = '\\$')])
additional_columns<-c('security_deposit','cleaning_fee','extra_people')

remove_dollar<-c(remove_dollar,additional_columns)
#strip dollar amount from these columns
AirBNB[,remove_dollar]<-apply(AirBNB[,remove_dollar],2,FUN = remove_sign,money = "\\$")

# convert characters to numeric columns

AirBNB[,remove_dollar]<-apply(AirBNB[,remove_dollar],2, FUN =as.numeric)  


```

4 types of data were read : integer, character, numeric, logical 

Since we loaded the data with the option string as Factors =FALSE. We will have to do some data manipulation to understand the right data type 


URL columns would not be useful therefore removing these columns 

```{r removeurlcolumns}
AirBNB<-removethesecolumns(pattern_remove = "url",dataset = AirBNB)
AirBNB<-removethesecolumns(pattern_remove = "scrape",dataset = AirBNB)

```


What columns have NA values 
We see that there are 2 columns which have no values at all. We can delete those columns. 
As a rule of thumb we can safely remove columns which have missing values in ~[80]% of the rows

```{r NAs}

how_many_NA<-as.data.frame(unlist(apply(AirBNB, 2, noofNA)))
kable(x = how_many_NA ,caption = "Missing value analysis")
AirBNB<-AirBNB %>% select(-c('license','has_availability'))

```

Since we will be matching on location ,let us check the data integrity of zipcodes and latitude and longitude

1) zipcode should be of length 5


```{r}

sum(str_count(AirBNB$zipcode,pattern = "[0-9]")==5)
nrow(AirBNB)-sum(str_count(AirBNB$zipcode,pattern = "[0-9]")==5)

```





There are columns which are disseminating no information. Let us analyze columns for unique values

```{r delete_no_information}

apply(AirBNB,2,analyze_distinct_values)
AirBNB<-AirBNB %>% select(-c('requires_license','experiences_offered'))

# converting into factor

```

From distinct value analysis we see that requires_license and experiences_offered have no information at all 


The consultancy company has already identified that 2 bedroom properties are the most profitable. 






```{r filter_2_rooms}
#
no_of_bedrooms<-2
air_two_room_property<-AirBNB %>% filter(AirBNB$bedrooms ==no_of_bedrooms)
how_many_NA_2_bedrooms<-as.data.frame(unlist(apply(air_two_room_property,MARGIN =  2, noofNA)))



```

#What properties to invest in ?


```{r mergeanalysis}

two_room_property<-merge(air_two_room_property,Z_NY_predicted,by = 'zipcode',suffixes = c('air','zil'))
two_room_property$neighbourhood_group_cleansed<-as.factor(two_room_property$neighbourhood_group_cleansed)

two_room_property$occupancy_score=two_room_property$review_scores_rating
kable(data.frame(occupancy_score=c('75-100','50-75','25-50','0-25'),occupancy_rate=c('75%','65%','55%','45%')),caption = "Occupancy rate based on review score and number of reviews")

two_room_property$occupancy_rate<-cut(two_room_property$occupancy_score, 
                    breaks = c(0,25,50,75,100), 
                    labels = c(".45", ".55", ".65", ".75"), 
                    right = TRUE)
two_room_property$occupancy_rate=as.numeric(as.character(two_room_property$occupancy_rate))
days=30
months=12
two_room_property$breakeven_years=two_room_property$X2017.06/(two_room_property$price*two_room_property$occupancy_rate*months*days)
sum(is.na(two_room_property$occupancy_rate))

# profit-loss matrix by taking averages across the zipcodes

two_room_property %>% group_by(zipcode) %>% summarise(avg_return_in_years=mean(breakeven_years,na.rm = T),avg_airbnb_price=mean(price,na.rm = T),avg_cost_price=mean(X2017.06,na.rm = T),count=n()) %>% arrange((avg_return_in_years))
 
# profit-loss matrix by taking median across the zipcodes

two_room_property %>% group_by(zipcode) %>% summarise(median_return_in_years=median(breakeven_years,na.rm = T),median_airbnb_price=median(price,na.rm = T),median_cost_price=median(X2017.06,na.rm = T),count=n()) %>% arrange((median_return_in_years))

```




 




###Identify which areas are good

```{r visualizations,fig.width=10,echo=FALSE,message=FALSE,warning=FALSE }

theme_set(theme_bw())

two_room_property %>% select(zipcode,price) %>% filter(zipcode>0)%>% group_by(zipcode)%>% summarise(n_count=n()) %>% arrange(desc(n_count))%>% top_n(n = 25)%>%
ggplot(data = .,mapping = aes(reorder(zipcode,-n_count),n_count,group=1))+geom_line(stat = 'identity')+geom_hline(yintercept = 70,linetype='dashed',color='red')+ggtitle("Count of properties plotted against zipcode")+xlab('zipcode')+ylab('count')  

# boxplot to show variations in price within a zipcode


ggplot(data=two_room_property,mapping = aes(zipcode,price))+
geom_boxplot(outlier.colour = "red",varwidth = TRUE)+ggtitle("Variation of price within a zipcode")


two_room_property %>% select(zipcode,price) %>% filter(zipcode>0)%>% group_by(zipcode)%>% summarise(avg_price=mean(price,na.rm = T),count=n()) %>%arrange(desc(avg_price),count)%>%mutate_if(is.numeric,round,digits=0)%>% top_n(n = 25)%>% ggplot(.,mapping = aes(reorder(zipcode,-avg_price),avg_price))+geom_bar(stat = "identity")+ggtitle("Plot of average AIRBNB price against zipcode")+xlab('zipcode')


two_room_property %>% select(zipcode,price) %>% filter(zipcode>0)%>% group_by(zipcode)%>% summarise(median_price=median(price,na.rm = T),count=n()) %>%arrange(desc(median_price),desc(count))%>%mutate_if(is.numeric,round,digits=0)%>% top_n(n = 25)%>% ggplot(.,mapping = aes(reorder(zipcode,-median_price),median_price))+geom_bar(stat = "identity",mapping = aes(fill="blue"))+ggtitle("Plot of median AIRBNB price against zipcode")+xlab("zipcode")

# In which neighborhood these properties are located 

two_room_property %>% group_by(neighbourhood_group_cleansed) %>% summarise(avg_price=mean(price,na.rm = T)) %>% arrange(desc(avg_price)) %>% select(neighbourhood_group_cleansed,avg_price)%>% ggplot(.,mapping = aes(neighbourhood_group_cleansed,avg_price,fill=neighbourhood_group_cleansed))+geom_bar(stat='identity')+xlab("neighbourhood")+ggtitle("Variation of price within the neighborhood")

# which zipcodes are located in which location 

ggplot(data=two_room_property,mapping=aes(zipcode,fill=neighbourhood_group_cleansed))+
geom_histogram(stat='count')+facet_grid(neighbourhood_group_cleansed~.)  
 


p1<-ggplot(data = Z_NY_predicted,mapping = aes(x=reorder(zipcode,-predicted_price),y=predicted_price))+
geom_bar(stat='identity')+ggtitle("Decreasing predicted price plotted against zipcode")+xlab("zipcode")


p2<-ggplot(data = Z_NY_predicted,mapping = aes(x=reorder(zipcode,-X2017.06),y=X2017.06))+
geom_bar(stat='identity')+ggtitle("Decreasing actual price plotted against zipcode")+xlab("zipcode")+ylab("June 2017")

grid.arrange(arrangeGrob(p1, p2))
  
```




If time permits I would like to check which kind of property is most suitable

```{r bedrooms}
class(AirBNB$bedrooms)
# let us see the distribution of the variable
table(AirBNB$bedrooms)
percentage_missing<-(sum(is.na(AirBNB$bedrooms))/nrow(AirBNB))*100
zero_bedrooms<-AirBNB[AirBNB$bedrooms==0,]


```

We observer two things 

1) 69 missing values or 0.17%
2) frequency distribution shows that there are 3525 properties which are having 0 bedrooms.
We will have to investigate this as to what kind of properties are they.


We will only look at those properties which are 2 bedrooms

Since 0 bedrooms can be a field which the user didn't enter or can be bad data


#Fixing bedrooms with zero length 



```{r fix_0_bedrooms}

ggplot(data = zero_bedrooms,mapping=aes(zero_bedrooms$beds,fill=zero_bedrooms$property_type))+
geom_histogram()+
scale_x_continuous(breaks = zero_bedrooms$beds)

  
```

Most of the data is for 1,2 and 3 beds

```{r price_analysis,eval=TRUE,echo=FALSE}


# p<-ggplot(data=zero_bedrooms %>% filter(beds<4),mapping = aes(zero_bedrooms$price))+
# geom_histogram(stat = 'count')

# p+facet_grid(vars(beds))

```

Clustering can be done using latitude or longitude. We will deal with this later

2) There are 618 rows which have improper length zipcodes. 

We can use latitudes and longtitudes for those locations and compare it with others but we will deal with it later

Bedrooms is the variable we are filtering on for now, although later in the analysis we will try to include bedrooms of size 0 